基于 Next.js 的「每日待办」Web 应用的开发计划

# Feature

* **用户认证**：支持用户注册、登录和登出。注册时将密码进行哈希存储，登录时校验凭证并生成 JWT 令牌，使用 HttpOnly Cookie 保存以保证安全（防止跨站脚本读取）。全局中间件会拦截请求检查此 JWT Cookie，如未登录则重定向到登录页。登录后用户会获得会话状态，可访问受保护的内容。登出操作则清除认证 Cookie。
* **每日待办管理**：提供创建、编辑、删除每日待办事项的功能。每个待办包含**标题**、**描述**、**日期**和**时间提醒**字段，支持标记完成或未完成。用户可以新增待办事项，修改内容或时间，删除不需要的待办，以及勾选标记任务完成/未完成。应用会根据日期组织待办事项（例如默认显示当日事项），并在界面上清晰区分已完成和未完成的任务状态。
* **数据持久化**：使用 SQLite 关系型数据库保存用户账户和待办事项数据。采用 Prisma ORM 进行数据库建模和访问，以提升开发效率。Prisma 在项目初始化时根据 schema 自动生成数据库客户端代码，并根据查询自动构建 SQL 语句执行，无需手写 SQL。通过 Prisma，我们可以方便地对数据库进行增删查改操作。数据模型设计上，每个用户和其待办事项通过外键关联，确保用户只能访问自己的待办数据。
* **响应式简洁 UI**：前端界面设计追求简洁直观，在不同设备上自适应布局。采用 **Tailwind CSS** 工具类库快速构建样式，利用其丰富的实用类实现响应式设计（只需添加如 `sm:`、`md:` 前缀即可适配不同屏幕）。可选地，引入 **Shadcn UI** 组件库来利用预构建的优雅 React 组件，加速开发并保持一致的视觉风格。整体配色和排版风格简约清爽，保证日常使用时界面清晰易读，交互友好。另将使用 **Framer Motion** 等动画库，为界面交互增添流畅的过渡效果，例如待办事项的新增、完成状态切换时的淡入淡出动画，提升用户体验的活泼性。
* **第三方集成**：结合浏览器通知和日历服务拓展应用功能。

  * **浏览器通知**：应用使用 **Web Notification API** 发送系统通知，在待办事项到达设定提醒时间时提醒用户。首次使用时会请求用户授予通知权限，只有在用户同意后才会显示提醒。通知内容包含待办标题及时间等信息，例如“您的任务‘购物’已到提醒时间”，即使用户未处于应用页面也能收到桌面通知。
  * **Google Calendar 同步（可选）**：支持通过 **OAuth 2.0** 授权将待办事项同步到用户的 Google 日历。用户可在设置中绑定谷歌账号，授权后应用获取访问其日历的令牌。此后，新建/更新待办事项时，后台调用 Google Calendar API 为用户创建/更新对应日历事件（标题为待办标题，时间为待办的日期和提醒时间）。这样，用户可在个人日历中查看每日待办安排。该功能为可选集成，实施时需妥善保存OAuth凭证并处理好令牌过期刷新等逻辑。

# UI

Tailwind CSS 将用于整体样式布局，而 Shadcn UI 可用于快速引入设计精美且可定制的组件。界面设计注重简洁直观，采用浅色调和简约风格，突出待办事项内容。本应用的界面包括用户登录/注册页和待办事项主页面，并针对移动端进行优化布局。Tailwind 提供的实用类使我们能够方便地实现响应式设计，针对不同屏幕尺寸调整布局而不需编写自定义媒体查询。同时，通过 Framer Motion 动画库，我们将为元素交互添加细腻的过渡效果，提升整体体验的一致性与流畅性。

## 登录与注册界面

登录页和注册页采用统一的表单组件风格，界面简洁居中。表单包含电子邮箱和密码等输入框，以及提交按钮。利用 Tailwind 的表单样式类快速构建布局，例如使用`flex flex-col`堆叠输入字段，适当的留白间距保证视觉清晰。为输入框和按钮应用 Shadcn UI 提供的无障碍组件样式，使其外观简洁且具有一致的交互反馈。注册表单提供重复密码确认及基础校验，确保密码合规。用户提交表单后，若发生错误（例如邮箱已被注册或密码错误），界面将及时反馈错误信息（使用 Tailwind 的文本样式将错误提示高亮）。注册成功后自动引导用户前往登录，登录成功则跳转进入待办事项主界面。

## 待办事项主界面

待办事项页面是应用的核心，主要由**任务列表**和**新增待办输入区**组成。页面顶部通常会显示欢迎信息和登出按钮（比如“你好，用户名”及“退出”链接），便于用户退出登录。主区域呈现按日期分类的待办事项列表：每条待办事项显示其标题、日期和时间等关键信息，未完成的事项旁有复选框可供勾选完成。采用简洁的卡片式布局列出待办事项，利用 Tailwind 的列表和间距类使多个任务条目分隔明显且不显拥挤。对于每个待办事项条目，标题突出显示，描述文字采用次要样式显示。完成的任务在界面上会以浅灰色或中划线样式标注，以直观区别于未完成状态。用户可点击复选框切换任务状态，或点击“编辑”按钮修改任务（弹出编辑表单，例如使用对话框组件）。新增待办区域通常放在列表顶部或底部，提供文本输入框让用户输入新任务内容、选择日期和时间，然后点击“添加”按钮提交。整个流程尽量做到所见即所得，用户一进入该页面即可浏览当日任务并进行各项操作。

## 响应式设计与动画

界面布局将针对不同设备屏幕进行优化。当在手机等小屏幕访问时，待办列表和输入表单将堆叠排列，文字和交互控件自动缩放以保证可读性；在平板或桌面端，则采用多栏布局（如侧边留白或弹性宽度）以充分利用空间。使用Tailwind的响应式断点类，可以在`sm`, `md`, `lg`等不同屏幕尺寸下调整样式，例如小屏幕下隐藏不必要的装饰元素、将文本改为更大字号等，从而确保移动端的良好体验。交互方面，我们将融入适度的动画效果：借助Framer Motion，实现待办项的动态呈现和状态切换动画。例如，当用户新增一条待办时，列表中相应项可以淡入滑动出现；勾选完成任务时，该项可伴随颜色变化和划线动画；删除任务时卡片淡出消失。页面切换（例如从登录页进入待办页）也会有平滑的过渡效果。所有动画遵循“优雅且克制”的原则，保证不喧宾夺主，又能增强操作的反馈，令用户感到应用流畅而富有品质。

# Logic

## 用户认证逻辑

**注册**：当用户提交注册信息时，服务器端首先使用 Prisma 查询用户表，按邮箱检查该用户是否已存在。若邮箱已被占用，则返回错误提示给前端；若不存在，则使用 bcrypt 库将明文密码加盐哈希后存储新用户记录（确保不保存明文密码）。上述操作通过 Prisma 的 `prisma.user.create` 完成，将新用户邮箱和哈希密码写入数据库。注册成功后，API 返回成功状态，前端可引导用户登录。

**登录**：当用户登录时，后端根据提供的邮箱在数据库查找用户。如果用户不存在或密码不匹配，则返回认证失败错误；如果匹配成功，后端会为该用户创建一个 JWT（JSON Web Token）作为登录会话标识。JWT 会包含用户的唯一ID等信息，使用服务器端的私钥进行签名以防篡改。随后，通过设置 HttpOnly Cookie（例如名称为`Authorization`）将该 JWT 下发给客户端浏览器保存。使用 HttpOnly 属性可防止客户端脚本访问令牌，提高安全性。每次请求时浏览器会自动附带该 Cookie，从而服务端可识别用户身份。

**访问控制**：应用采用 Next.js 中间件机制对受保护路由进行拦截。在 `middleware.ts` 中，我们会提取请求的路径并检查 JWT Cookie 是否存在及有效。如果用户未登录且企图访问受保护的待办事项页面，则中间件会立即重定向到登录页，阻止未授权访问。反之，若用户已登录但尝试访问登录或注册页，也会被重定向到主应用页面，避免重复登录。JWT 的验证可以通过服务器端解码并校验签名完成，一般在中间件或API层使用如 `jsonwebtoken`/`jose` 等库校验令牌。通过这种方式，后端在每次请求时都能确认用户身份，保护接口安全。**登出**：当用户点击登出时，前端调用登出接口，后端会清除掉 JWT Cookie（将其失效或删除），同时前端重定向回登录页，结束用户会话。

## 每日待办事项逻辑

待办事项的增删改查通过 Next.js 提供的 API 路由来实现。我们将在`/api/todo`下实现 RESTful 风格的接口，包括 GET（获取待办列表）、POST（创建待办）、PUT（更新待办）、DELETE（删除待办）等方法。所有这些操作都要求用户已登录，通过上文提到的 JWT 验证来确保请求者身份合法。例如，获取待办列表时，服务器会从 JWT 中提取用户ID或由前端请求时附带用户ID参数，然后使用 Prisma 查询该用户在数据库中对应的所有待办记录。查询采用 `prisma.todo.findMany` 按照用户ID过滤，实现只返回当前用户自己的待办事项列表。

**创建待办**：用户提交新待办（标题、描述、日期、时间等）后，后端首先进行基本校验（如标题非空、日期格式正确等）。然后通过 Prisma 的创建方法将新记录插入数据库，关联到该用户ID。例如，使用 `prisma.todoList.create({ data: { title, description, dueDate, dueTime, userId } })` 将待办保存。成功插入后，返回包含新待办项的完整数据（包括生成的ID等）给前端，前端再更新界面列表。

**编辑待办**：当用户修改某条待办（例如更改描述或提醒时间）时，前端调用 PUT 接口提交待办ID及修改后的字段。后端收到请求后，会先校验该待办是否属于当前用户（可根据JWT的用户ID确保安全），然后使用 Prisma 的更新方法执行更新。比如通过 `prisma.todoList.update({ where: { id }, data: { ...更新内容... } })` 来修改记录。更新成功后将新的数据返回，以便前端同步显示更改结果。

**删除待办**：前端调用 DELETE 接口并附带待办ID时，后端同样验证该记录归属，并使用 Prisma 删除该 ID 的待办记录。删除操作会移除数据库中的记录，并返回结果状态；前端收到成功响应后即可在界面上移除相应的待办项。

**标记完成/未完成**：这是待办项的特殊更新操作。用户勾选或取消勾选任务时，前端调用 PUT 接口，仅提交任务ID和新的完成状态（例如 `complete: true/false`）。后端据此更新数据库中该记录的完成标志位。由于 Prisma 允许部分字段更新，我们可以仅修改 `complete` 字段而不影响其他数据。标记完成后，如果需要，也可以在响应中返回当前任务的新状态，或由前端直接更新列表UI呈现已完成效果。

上述待办相关操作都遵循**权限检查**和**错误处理**：每次操作会先验证用户身份和数据有效性，例如防止用户通过构造请求操作他人任务、避免创建空标题的任务等。如果出现违规请求或异常（如数据库错误），后端会返回适当的错误码和信息，前端则提示用户相应的错误原因。

## 通知与提醒逻辑

*桌面通知示例：当待办事项到达设定时间时，应用通过 Notification API 弹出系统通知提醒用户。图示为浏览器通知显示“HEY! Your task 'Go shopping' is now overdue”（你的任务“Go shopping”已超时）。实际应用中通知内容会根据待办标题和时间生成。*

本应用将在待办事项的提醒时间点，为用户触发系统通知提醒其执行任务。实现流程如下：首先，在用户登录并进入待办页面时，应用会请求浏览器通知权限。只有获得用户授权后，才可以发送通知。我们会在用户与页面交互（例如点击“启用通知”按钮）时调用 `Notification.requestPermission()` 方法，以弹出浏览器权限请求框供用户选择。权限状态可能是“granted”（同意）、“denied”（拒绝）或“default”（未响应)。若用户同意，我们将继续设置提醒逻辑；如果拒绝或关闭，则不打扰用户。

对于**通知的调度**，前端会获取用户当日及未来待办事项的列表，找出设有提醒时间的任务。可以采用`setTimeout`或`setInterval`在浏览器端进行简易调度：计算当前时间与待办提醒时间的差值，然后在相应延迟后触发通知。例如，如果当前时间是10:00，而某任务设定的提醒时间是10:30，则设置一个 30 分钟的延迟计时器，到时调用通知函数。为了可靠性，我们也可以每隔一段时间检查快到期的任务并提醒。对于网页长时间未打开的情况，可考虑使用 Service Worker 和 Push API 实现后台通知，但这属于更高级的拓展。

当计时到达时，应用将使用 `new Notification(title, options)` 构造一个通知。通知标题可以统一设为应用名称或固定前缀（如“每日待办提醒”），正文内容包含具体任务标题和时间。例如，上图所示 MDN 示例代码创建了一则通知，标题“To do list”，正文包含任务名称和状态。本应用中，我们可能设置通知标题为「待办事项提醒」，正文为例如`您的任务 "开会事项" 时间到了`，这样用户能一眼了解是哪条任务。在通知触发时，系统会在桌面显示通知横幅，或在移动设备上弹出通知窗口，提示用户及时查看或处理任务。用户点击通知后，可引导打开应用并高亮相关任务（这一点可以通过监听通知点击事件实现）。总之，通过浏览器通知，用户即使没有主动查看应用，也能收到重要待办的提醒，提高了任务管理的有效性和及时性。

## Google Calendar 同步逻辑 (可选)

Google 日历同步功能使用户的待办事项与其个人日历保持一致。启用该功能需要经过 OAuth2 授权流程：当用户选择绑定 Google Calendar 时，前端会引导用户跳转到 Google 的 OAuth 授权页面，请求允许我们的应用访问其日历。此次请求包括我们在 Google API 控制台注册的**OAuth客户端ID**等信息以及需要的权限范围(scope)，例如“[https://www.googleapis.com/auth/calendar.events”等，对应创建和管理日历事件的权限。](https://www.googleapis.com/auth/calendar.events”等，对应创建和管理日历事件的权限。)

用户在 Google 授权页面同意后，浏览器会重定向回我们的应用并附带一个授权码。后端使用此授权码向 Google 服务器换取访问令牌和刷新令牌。访问令牌用于调用 Google Calendar API，而刷新令牌可长期使用来获取新的访问令牌（因为访问令牌通常短时有效）。我们会将用户的 Google OAuth凭证安全地保存起来（例如存入数据库的用户表字段，包含`google_access_token`、`google_refresh_token`和`token_expiry`等），以便后续调用日历API。**安全考虑**：这些敏感令牌会加密保存，并且刷新令牌只在用户第一次连接时获取一次。

完成授权绑定后，当用户在我们的待办应用中新建或修改待办事项时，后端会相应地调用 Google Calendar API。在用户创建待办的API逻辑中，如果检测到用户已绑定Google（日历令牌存在且有效），则额外执行以下操作：构造 Google Calendar 的事件数据结构，将待办事项标题作为日历事件的标题，待办的日期和时间组合转换为事件的开始/结束时间（可以设定为提醒时间点的一个短事件或者使用日历的提醒功能）。然后通过 Google 提供的客户端库或 HTTP 请求调用 `events.insert` 接口，在用户的日历中新建一条事件。Google Calendar 会根据事件时间自动发送提醒通知（如果用户在日历中启用了通知），这与我们应用内的通知形成互补。类似地，若用户在应用中编辑了待办（特别是修改时间或标题），我们可以调用 `events.update` 接口同步更新日历中的对应事件。为此需要在首次创建事件时保存返回的 `eventId`，将其关联到本地待办记录（例如在数据库的待办表中新增一个字段存储 Google 日历的事件ID）。删除待办事项时，如有对应的 Google Calendar 事件，亦可调用 `events.delete` 将其从用户日历移除，保持两边一致。

考虑到此功能的可选性质，实现时应确保不影响核心待办功能：未绑定谷歌账号的用户，应用应完全按默认逻辑运行；而已绑定的用户，如果谷歌令牌失效，需要处理刷新令牌以续期，或提醒用户重新绑定。由于 Google API 调用涉及网络请求和潜在延迟，我们会在后台异步执行这些同步操作，尽量避免阻塞用户在应用中的正常操作。例如，新建待办时先快速完成本地数据库写入并反馈给前端，随后再调用谷歌API同步（可以使用消息队列或后台任务），同步成功或失败均记录但不影响用户主流程。这种设计提高了系统的健壮性。

通过 Google Calendar 集成，用户可以在自己常用的日历应用中查看和管理待办事项，提高跨应用的时间管理一致性。这对于有在多个设备查看日程需求的用户将非常有价值。但鉴于实现复杂度，此功能为扩展目标，可在核心功能开发完善后再行开发部署。

# Models

## User 模型

\*\*User（用户表）\*\*用于存储用户账号信息，包括以下字段：

* `id`：主键，唯一标识用户。类型可用递增整数或 UUID。使用 Prisma 可将其设为自增整数或采用 CUID/UUID 默认值。
* `email`：字符串，用户邮箱（或用户名）**，需唯一**。用于登录和联系，建立唯一索引避免重复注册。
* `passwordHash`：字符串，保存加密后的密码摘要。注册时由明文密码经 bcrypt 哈希得到。长度固定（如60字符的bcrypt散列），确保不存储明文密码以保护安全。
* `createdAt`：日期时间，记录账户创建时间，默认值为当前时间。
* `updatedAt`：日期时间，记录最近一次更新用户记录的时间，由数据库自动维护在每次修改时刷新。

可选字段：如`name`（用户昵称）、`avatar`（头像URL）等，视产品需求添加。若启用Google同步，还需存储OAuth凭证：例如`googleAccessToken`、`googleRefreshToken`、`googleTokenExpiry`等字段，用于保存用户授权Google API的令牌，方便后台调用谷歌服务。上述凭证字段应加密或采取安全措施存储。

关系方面，每个 User 可以关联多个 Todo（一对多关系），通过主键-外键关联实现。

## Todo 模型

\*\*Todo（待办事项表）\*\*用于存储用户创建的每条待办任务，包含如下字段：

* `id`：主键，唯一标识一条待办事项，类型为自增整数或UUID。
* `userId`：外键，关联到所属的用户的id。表示该待办由哪个用户创建，数据库层面建立外键约束引用 User 表，以实现**每条待办从属于特定用户**的关系。
* `title`：字符串，待办事项标题或名称。简明扼要描述任务内容，非空，例如“提交报告”。
* `description`：文本，待办的详细描述或备注，可选字段。用户可以填写任务的详细信息，长度允许较长但也可设置上限（例如255字符）以控制存储大小。
* `dueDate`：日期，表示待办事项计划执行的日期。例如2025-08-15。用于将任务按天归类，“每日待办”即通过此字段区分天数。
* `dueTime`：时间，表示提醒的具体时间点，例如14:30。结合dueDate，可以组成完整的提醒时间。存储上可以用时间类型或 DateTime 类型；若使用单一 DateTime 类型字段`dueDateTime`也可以涵盖日期和时间，本方案为理解清晰选择分别存储日期和时间。
* `completed`：布尔值，标识任务是否已完成。默认值为false（未完成）。当用户勾选完成时置为true。通过该字段可以筛选未完成任务列表，或在界面显示上做不同样式区分。
* `createdAt`：日期时间，记录待办创建时间，默认当前时间戳。
* `updatedAt`：日期时间，记录最后一次编辑该待办的时间，利用 Prisma 的钩子或数据库触发器在修改时自动更新。

通过上述字段设计，我们可以满足待办事项的主要信息需求和排序、筛选需求（例如按日期聚合、按完成状态过滤）。在 Prisma 模式文件中，会定义 User 和 Todo 两个模型以及它们的一对多关系，比如：User模型包含`todos: Todo[]`虚拟关联，Todo模型包含`user: User`引用以及`userId`外键字段。这使我们能够方便地查询用户及其相关的任务列表。利用 Prisma 提供的 ORM 方法，可以很方便地对这些模型进行CRUD操作而无需手写SQL。

为了优化查询性能，我们将在 Todo 表的`userId`上建立索引（Prisma 可在schema中声明），以加速按用户筛选待办的查询。同时，可以根据需要在`dueDate`上建立索引以优化按日期筛选。当任务数据量增大时，这些索引有助于保持查询高效。

综上，数据模型通过 Prisma 定义后，可由 `prisma migrate` 等命令生成对应的 SQLite 表结构。Prisma Client 将为我们提供类型化的方法，对 User 和 Todo 模型进行增删查改。例如，使用 `prisma.user.findUnique` 按邮箱查找用户用于登录验证，使用 `prisma.todo.findMany` 获取指定用户的所有待办事项，等等。在代码层面，这些模型的定义和关联关系确保了数据的一致性和操作的便利性，为应用功能的实现提供了坚实的基础。
